<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java设计模式 | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Java设计模式学习创建型模式简单工厂模式简单工厂模式严格意义上来说，并不属于设计模式中的一种，不过这里还是简单记录下。 定义：由一个工厂对象决定创建出哪一种类型实例。客户端只需传入工厂类的参数，无心关心创建过程。 优点：具体产品从客户端代码中抽离出来，解耦。 缺点：工厂类职责过重，增加新的类型时，得修改工程类得代码，违背开闭原则。 举例：新建Fruit水果抽象类，包含eat抽象方法： 1234p">
<meta property="og:type" content="article">
<meta property="og:title" content="Java设计模式">
<meta property="og:url" content="http://example.com/2021/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java设计模式学习创建型模式简单工厂模式简单工厂模式严格意义上来说，并不属于设计模式中的一种，不过这里还是简单记录下。 定义：由一个工厂对象决定创建出哪一种类型实例。客户端只需传入工厂类的参数，无心关心创建过程。 优点：具体产品从客户端代码中抽离出来，解耦。 缺点：工厂类职责过重，增加新的类型时，得修改工程类得代码，违背开闭原则。 举例：新建Fruit水果抽象类，包含eat抽象方法： 1234p">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-11-30T16:02:17.000Z">
<meta property="article:modified_time" content="2021-12-06T15:22:31.834Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-06 23:22:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-11-30T16:02:17.000Z" title="Created 2021-12-01 00:02:17">2021-12-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-12-06T15:22:31.834Z" title="Updated 2021-12-06 23:22:31">2021-12-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java设计模式学习"><a href="#Java设计模式学习" class="headerlink" title="Java设计模式学习"></a>Java设计模式学习</h2><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式严格意义上来说，并不属于设计模式中的一种，不过这里还是简单记录下。</p>
<p><strong>定义</strong>：由一个工厂对象决定创建出哪一种类型实例。客户端只需传入工厂类的参数，无心关心创建过程。</p>
<p><strong>优点</strong>：具体产品从客户端代码中抽离出来，解耦。</p>
<p><strong>缺点</strong>：工厂类职责过重，增加新的类型时，得修改工程类得代码，违背开闭原则。</p>
<p>举例：新建Fruit水果抽象类，包含eat抽象方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Fruit &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其实现类Apple：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Apple extends Fruit&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃🍎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建创建Fruit的工厂类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FruitFactory &#123;</span><br><span class="line"></span><br><span class="line">    public Fruit produce(String name) &#123;</span><br><span class="line">        if (&quot;apple&quot;.equals(name)) &#123;</span><br><span class="line">            return new Apple();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建个客户端测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FruitFactory factory &#x3D; new FruitFactory();</span><br><span class="line">        Fruit fruit &#x3D; factory.produce(&quot;apple&quot;);</span><br><span class="line">        fruit.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行main方法，输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吃🍎</span><br></pre></td></tr></table></figure>


<p>可以看到，客户端Application并未依赖具体的水果类型，只关心FruitFactory的入参，这就是客户端和具体产品解耦的体现，UML图如下：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191216103019.png" alt="QQ截图20191216103019.png"></p>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>为了解决简单工厂模式的缺点，诞生了工厂方法模式（Factory method pattern）。</p>
<p><strong>定义</strong>：定义创建对象的接口，让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到了子类进行。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>具体产品从客户端代码中抽离出来，解耦。</li>
<li>加入新的类型时，只需添加新的工厂方法（无需修改旧的工厂方法代码），符合开闭原则。</li>
</ol>
<p><strong>缺点</strong>：类的个数容易过多，增加复杂度。</p>
<p>举例：新建Fruit抽象类，包含eat抽象方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Fruit &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建FruitFactory抽象工厂，定义produceFruit抽象方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class FruitFactory &#123;</span><br><span class="line"></span><br><span class="line">    public abstract Fruit produceFruit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建Fruit的实现类，Apple：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Apple extends Fruit &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;吃🍎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建FruitFactory的实现类AppleFruitFactory，用于生产具体类型的水果 —— 苹果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AppleFruitFactory extends FruitFactory&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Fruit produceFruit() &#123;</span><br><span class="line">        return new Apple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建客户端Application测试一波：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FruitFactory factory &#x3D; new AppleFruitFactory();</span><br><span class="line">        Fruit fruit &#x3D; factory.produceFruit();</span><br><span class="line">        fruit.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行main方法，输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吃🍎</span><br></pre></td></tr></table></figure>


<p>现在要新增Banana类型的水果，只需要新增Banana类型的工厂类即可，无需修改现有的AppleFruitFactory代码，符合开闭原则。但是这种模式的缺点也显而易见，就是类的个数容易过多，增加复杂度。</p>
<p>上面例子UML图如下所示：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191216105317.png" alt="QQ截图20191216105317.png"></p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式（Abstract factory pattern）提供了<strong>一系列</strong>相关或者相互依赖的对象的接口，关键字是“一系列”。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>具体产品从客户端代码中抽离出来，解耦。</li>
<li>将一个系列的产品族统一到一起创建。</li>
</ol>
<p><strong>缺点</strong>：拓展新的功能困难，需要修改抽象工厂的接口；</p>
<p>综上所述，抽象工厂模式适合那些功能相对固定的产品族的创建。</p>
<p>举例：新建水果抽象类Fruit，包含buy抽象方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Fruit &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void buy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建价格抽象类Price，包含pay抽象方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Price &#123;</span><br><span class="line"></span><br><span class="line">    public abstract void pay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建水果创建工厂接口FruitFactory，包含获取水果和价格抽象方法（产品族的体现是，一组产品包含水果和对应的价格）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface FruitFactory &#123;</span><br><span class="line"></span><br><span class="line">    Fruit getFruit();</span><br><span class="line">    Price getPrice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接下来开始创建🍎这个“产品族”。新建Fruit实现类AppleFruit：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class AppleFruit extends Fruit&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void buy() &#123;</span><br><span class="line">        System.out.println(&quot;购买🍎&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建对应的苹果价格实现ApplePrice：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ApplePrice extends Price&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void pay() &#123;</span><br><span class="line">        System.out.println(&quot;🍎单价2元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建客户端Application，测试一波：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FruitFactory factory &#x3D; new AppleFruitFactory();</span><br><span class="line">        factory.getFruit().buy();</span><br><span class="line">        factory.getPrice().pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">购买🍎</span><br><span class="line">🍎单价2元</span><br></pre></td></tr></table></figure>


<p>客户端只需要通过创建AppleFruitFactory就可以获得苹果这个产品族的所有内容，包括苹果对象，苹果价格。要新建🍌的产品族，只需要实现FruitFactory、Price和Fruit接口即可。这种模式的缺点和工厂方法差不多，就是类的个数容易过多，增加复杂度。</p>
<p>上面例子UML图如下所示：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191216112922.png" alt="QQ截图20191216112922.png"></p>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>建造者模式也称为生成器模式（Builder Pattern），将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。简单来说就是，相同的过程可以创建不同的产品。</p>
<p>将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
<p>简单来说就是，相同的过程可以创建不同的产品。</p>
<p>适用于：</p>
<ol>
<li>一个对象有非常复杂的内部结构（很多属性）</li>
<li>想将复杂对象的创建和使用分离。</li>
</ol>
<p><strong>优点</strong>：</p>
<ol>
<li>封装性好，创建和使用分离</li>
<li>拓展性好，建造类之间独立，一定程度上解耦。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>产生多余的Builder对象；</li>
<li>产品内部发生变化，建造者需要更改，成本较大。</li>
</ol>
<p>举个例子：</p>
<p>新增商铺类Shop，包含名称，地点和类型属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Shop &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String location;</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Shop&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, location&#x3D;&#39;&quot; + location + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, type&#x3D;&#39;&quot; + type + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLocation() &#123;</span><br><span class="line">        return location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLocation(String location) &#123;</span><br><span class="line">        this.location &#x3D; location;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type &#x3D; type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接着创建Shop抽象生成器ShopBuilder：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ShopBuilder &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String location;</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    public abstract void name(String name);</span><br><span class="line">    public abstract void location(String location);</span><br><span class="line">    public abstract void type(String type);</span><br><span class="line"></span><br><span class="line">    public abstract Shop build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>包含和Shop相同的属性及对应的抽象构建方法。</p>
<p>继续创建ShopBuilder的实现，水果店构造器FruitShopBuilder：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class FruitShopBuilder extends ShopBuilder&#123;</span><br><span class="line"></span><br><span class="line">    private Shop shop &#x3D; new Shop();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void name(String name) &#123;</span><br><span class="line">        this.shop.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void location(String location) &#123;</span><br><span class="line">        this.shop.setLocation(location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void type(String type) &#123;</span><br><span class="line">        this.shop.setType(type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shop build() &#123;</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建个经销商类Dealer，用于通过ShopBuilder构建具体的商店：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Dealer &#123;</span><br><span class="line"></span><br><span class="line">    private ShopBuilder builder;</span><br><span class="line"></span><br><span class="line">    public void setBuilder(ShopBuilder builder) &#123;</span><br><span class="line">        this.builder &#x3D; builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Shop build(String name, String location, String type) &#123;</span><br><span class="line">        this.builder.name(name);</span><br><span class="line">        this.builder.location(location);</span><br><span class="line">        this.builder.type(type);</span><br><span class="line">        return builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建个客户端Application测试一波：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ShopBuilder builder &#x3D; new FruitShopBuilder();</span><br><span class="line">        Dealer dealer &#x3D; new Dealer();</span><br><span class="line">        dealer.setBuilder(builder);</span><br><span class="line"></span><br><span class="line">        Shop shop &#x3D; dealer.build(&quot;XX水果店&quot;, &quot;福州市XX区XX街XX号&quot;, &quot;水果经营&quot;);</span><br><span class="line">        System.out.println(shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shop&#123;name&#x3D;&#39;XX水果店&#39;, location&#x3D;&#39;福州市XX区XX街XX号&#39;, type&#x3D;&#39;水果经营&#39;&#125;</span><br></pre></td></tr></table></figure>


<p>这个例子是典型的建造者模式，UML图如下所示：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191216162813.png" alt="QQ截图20191216162813.png"></p>
<p>其实建造者模式更为常用的例子是下面这个：</p>
<p>创建一个店铺类Shop，Shop里包含构造该Shop的内部类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Shop &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String location;</span><br><span class="line">    private String type;</span><br><span class="line"></span><br><span class="line">    public Shop(ShopBuilder builder) &#123;</span><br><span class="line">        this.name &#x3D; builder.name;</span><br><span class="line">        this.location &#x3D; builder.location;</span><br><span class="line">        this.type &#x3D; builder.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Shop&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, location&#x3D;&#39;&quot; + location + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, type&#x3D;&#39;&quot; + type + &#39;\&#39;&#39; +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class ShopBuilder &#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private String location;</span><br><span class="line">        private String type;</span><br><span class="line"></span><br><span class="line">        public ShopBuilder name(String name) &#123;</span><br><span class="line">            this.name &#x3D; name;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ShopBuilder location(String location) &#123;</span><br><span class="line">            this.location &#x3D; location;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ShopBuilder type(String type) &#123;</span><br><span class="line">            this.type &#x3D; type;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Shop build() &#123;</span><br><span class="line">            return new Shop(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在客户端构建Shop只需：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Shop shop &#x3D; new Shop.ShopBuilder()</span><br><span class="line">                .name(&quot;XX水果店&quot;)</span><br><span class="line">                .location(&quot;福州市XX区XX街XX号&quot;)</span><br><span class="line">                .type(&quot;水果经营&quot;)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(shop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这种用法和Lombok的@Builder注解效果是一样的。</p>
<p>这个例子的UML图：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191216163308.png" alt="QQ截图20191216163308.png"></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式目的是为了一个类只有一个实例。</p>
<p>优点：</p>
<ol>
<li>内存中只有一个实例，减少了内存开销；</li>
<li>可以避免对资源的多重占用；</li>
<li>设置全局访问点，严格控制访问。</li>
</ol>
<p>缺点：</p>
<ol>
<li>没有接口，拓展困难。</li>
</ol>
<h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p>懒汉模式下的单例写法是最简单的，但它是线程不安全的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static LazySingleton lazySingleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        if (lazySingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">            lazySingleton &#x3D; new LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可加同步锁解决线程安全问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static LazySingleton lazySingleton &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton getInstance() &#123;</span><br><span class="line">        synchronized (LazySingleton.class) &#123;</span><br><span class="line">            if (lazySingleton &#x3D;&#x3D; null) &#123;</span><br><span class="line">                lazySingleton &#x3D; new LazySingleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>但是同步锁锁的是整个类，比较消耗资源，并且即使运行内存中已经存在LazySingleton，调用其getInstance还是会上锁，所以这种写法也不是很好。</p>
<h4 id="双重同步锁单例模式"><a href="#双重同步锁单例模式" class="headerlink" title="双重同步锁单例模式"></a>双重同步锁单例模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LazyDoubleCheckSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static LazyDoubleCheckSingleton instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private LazyDoubleCheckSingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazyDoubleCheckSingleton getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (LazyDoubleCheckSingleton.class) &#123;</span><br><span class="line">                if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    instance &#x3D; new LazyDoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子虽然加了同步锁，但它还是线程不安全的。虽然上面的例子不会出现多次初始化LazyDoubleCheckSingleton实例的情况，但是由于指令重排的原因，某些线程可能会获取到空对象，后续对该对象的操作将触发空指针异常。</p>
<p>要修复这个问题，只需要阻止指令重排即可，所以可以给instance属性加上volatile关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class LazyDoubleCheckSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private volatile static LazyDoubleCheckSingleton instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private LazyDoubleCheckSingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazyDoubleCheckSingleton getInstance() &#123;</span><br><span class="line">        if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (LazyDoubleCheckSingleton.class) &#123;</span><br><span class="line">                if (instance &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    instance &#x3D; new LazyDoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>相关博文：<a target="_blank" rel="noopener" href="https://mrbird.cc/volatile.html">深入理解volatile关键字</a>。</p>
<p>上面这种写法是不但确保了线程安全，并且当LazyDoubleCheckSingleton实例创建好后，后续再调用其getInstance方法不会上锁。</p>
<h4 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h4><p>看例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class StaticInnerClassSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private StaticInnerClassSingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class InnerClass &#123;</span><br><span class="line">        private static StaticInnerClassSingleton instance &#x3D; new StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static StaticInnerClassSingleton getInstance() &#123;</span><br><span class="line">        return InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>为什么这个例子是可行的呢？主要有两个原因：</p>
<ol>
<li>JVM在类的初始化阶段会加Class对象初始化同步锁，同步多个线程对该类的初始化操作；</li>
<li>静态内部类InnerClass的静态成员变量instance在方法区中只会有一个实例。</li>
</ol>
<p>在Java规范中，当以下这些情况首次发生时，A类将会立刻被初始化：</p>
<ol>
<li>A类型实例被创建；</li>
<li>A类中声明的静态方法被调用；</li>
<li>A类中的静态成员变量被赋值；</li>
<li>A类中的静态成员被使用（非常量）；</li>
</ol>
<h4 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h4><p>“饿汉”意指在类加载的时候就初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private final static HungrySingleton instance &#x3D; new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这种模式在类加载的时候就完成了初始化，所以并不存在线程安全性问题；但由于不是懒加载，饿汉模式不管需不需要用到实例都要去创建实例，如果创建了不使用，则会造成内存浪费。</p>
<h4 id="序列化破坏单例模式"><a href="#序列化破坏单例模式" class="headerlink" title="序列化破坏单例模式"></a>序列化破坏单例模式</h4><p>前面的单例例子在实现序列化接口后都能被序列化的方式破坏，比如HungrySingleton，让其实现序列化接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; -8073288969651806838L;</span><br><span class="line"></span><br><span class="line">    private final static HungrySingleton instance &#x3D; new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后创建Application测试一下如何破坏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        &#x2F;&#x2F; 演示序列化破坏单例</span><br><span class="line">        HungrySingleton instance &#x3D; HungrySingleton.getInstance();</span><br><span class="line">        ObjectOutputStream outputStream &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;file&quot;));</span><br><span class="line">        outputStream.writeObject(instance);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream inputStream &#x3D; new ObjectInputStream(new FileInputStream(&quot;file&quot;));</span><br><span class="line">        HungrySingleton newInstance &#x3D; (HungrySingleton) inputStream.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance &#x3D;&#x3D; newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc.mrbird.design.pattern.creational.singleton.HungrySingleton@7f31245a</span><br><span class="line">cc.mrbird.design.pattern.creational.singleton.HungrySingleton@6d03e736</span><br><span class="line">false</span><br></pre></td></tr></table></figure>


<p>可以看到，虽然是单例模式，但却成功创建出了两个不一样的实例，单例遭到了破坏。</p>
<p>要让反序列化后的对象和序列化前的对象是同一个对象的话，可以在HungrySingleton里加上readResolve方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; -8073288969651806838L;</span><br><span class="line"></span><br><span class="line">    private final static HungrySingleton instance &#x3D; new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 新增</span><br><span class="line">    private Object readResolve() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>再次运行Application的main方法后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc.mrbird.design.pattern.creational.singleton.HungrySingleton@7f31245a</span><br><span class="line">cc.mrbird.design.pattern.creational.singleton.HungrySingleton@7f31245a</span><br><span class="line">true</span><br></pre></td></tr></table></figure>


<p>可以看到，这种方式最终反序列化出来的对象和序列化对象是同一个对象。但这种方式反序列化过程内部还是会重新创建HungrySingleton实例，只不过因为HungrySingleton类定义了readResolve方法（方法内部返回instance引用），反序列化过程会判断目标类是否定义了readResolve该方法，是的话则通过反射调用该方法。</p>
<h4 id="反射破坏单例模式"><a href="#反射破坏单例模式" class="headerlink" title="反射破坏单例模式"></a>反射破坏单例模式</h4><p>除了序列化能破坏单例外，反射也可以，举个反射破坏HungrySingleton的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        HungrySingleton instance &#x3D; HungrySingleton.getInstance();</span><br><span class="line">        &#x2F;&#x2F; 反射创建实例</span><br><span class="line">        Class&lt;HungrySingleton&gt; c &#x3D; HungrySingleton.class;</span><br><span class="line">        &#x2F;&#x2F; 获取构造器</span><br><span class="line">        Constructor&lt;HungrySingleton&gt; constructor &#x3D; c.getDeclaredConstructor();</span><br><span class="line">        &#x2F;&#x2F; 打开构造器权限</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        HungrySingleton newInstance &#x3D; constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance &#x3D;&#x3D; newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cc.mrbird.design.pattern.creational.singleton.HungrySingleton@1b6d3586</span><br><span class="line">cc.mrbird.design.pattern.creational.singleton.HungrySingleton@4554617c</span><br><span class="line">false</span><br></pre></td></tr></table></figure>


<p>可以看到，我们通过反射破坏了私有构造器权限，成功创建了新的实例。</p>
<p>对于这种情况，饿汉模式下的例子可以在构造器中添加判断逻辑来防御（懒汉模式的就没有办法了），比如修改HungrySingleton的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private final static HungrySingleton instance &#x3D; new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line">        if (instance !&#x3D; null) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;forbidden&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HungrySingleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>再次运行Application的main方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">    at cc.mrbird.design.pattern.creational.singleton.Application.main(Application.java:33)</span><br><span class="line">Caused by: java.lang.RuntimeException: forbidden</span><br><span class="line">    at cc.mrbird.design.pattern.creational.singleton.HungrySingleton.&lt;init&gt;(HungrySingleton.java:16)</span><br><span class="line">    ... 5 more</span><br></pre></td></tr></table></figure>


<h4 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式"></a>枚举单例模式</h4><p>枚举单例模式是推荐的单例模式，它不仅可以防御序列化攻击，也可以防御反射攻击。举个枚举单例模式的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public enum EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Object data;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton getInstance()&#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>验证下是否是单例的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        EnumSingleton instance &#x3D; EnumSingleton.getInstance();</span><br><span class="line">        instance.setData(new Object());</span><br><span class="line">        EnumSingleton newInstance &#x3D; EnumSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance.getData());</span><br><span class="line">        System.out.println(newInstance.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE</span><br><span class="line">INSTANCE</span><br><span class="line">java.lang.Object@1b6d3586</span><br><span class="line">java.lang.Object@1b6d3586</span><br></pre></td></tr></table></figure>


<p>测试下序列化攻击：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        EnumSingleton instance &#x3D; EnumSingleton.getInstance();</span><br><span class="line">        instance.setData(new Object());</span><br><span class="line">        ObjectOutputStream outputStream &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;file&quot;));</span><br><span class="line">        outputStream.writeObject(instance);</span><br><span class="line">       </span><br><span class="line">        ObjectInputStream inputStream &#x3D; new ObjectInputStream(new FileInputStream(&quot;file&quot;));</span><br><span class="line">        EnumSingleton newInstance &#x3D; (EnumSingleton) inputStream.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance &#x3D;&#x3D; newInstance);</span><br><span class="line"></span><br><span class="line">        System.out.println(instance.getData());</span><br><span class="line">        System.out.println(newInstance.getData());</span><br><span class="line">        System.out.println(instance.getData() &#x3D;&#x3D; newInstance.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE</span><br><span class="line">INSTANCE</span><br><span class="line">true</span><br><span class="line">java.lang.Object@568db2f2</span><br><span class="line">java.lang.Object@568db2f2</span><br><span class="line">true</span><br></pre></td></tr></table></figure>


<p>可以看到序列化和反序列化后的对象是同一个。</p>
<p>原理：跟踪ObjectInputStream#readObject源码，其中当反编译对象为枚举类型时，将调用readEnum方法：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191217155448.png" alt="QQ截图20191217155448.png"></p>
<p>name为枚举类里的枚举常量，对于线程来说它是唯一的，存在方法区，所以通过<code>Enum.valueOf((Class)cl, name)</code>方法得到的枚举对象都是同一个。</p>
<p>再测试一下反射攻击：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        EnumSingleton instance &#x3D; EnumSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">        Class&lt;EnumSingleton&gt; c &#x3D; EnumSingleton.class;</span><br><span class="line">        &#x2F;&#x2F; 枚举类只包含一个(String,int)类型构造器</span><br><span class="line">        Constructor&lt;EnumSingleton&gt; constructor &#x3D; c.getDeclaredConstructor(String.class, int.class);</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        EnumSingleton newInstance &#x3D; constructor.newInstance(&quot;hello&quot;, 1);</span><br><span class="line"></span><br><span class="line">        System.out.println(instance &#x3D;&#x3D; newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:417)</span><br><span class="line">    at cc.mrbird.design.pattern.creational.singleton.Application.main(Application.java:71)</span><br></pre></td></tr></table></figure>


<p>可以看到抛异常了，查看Constructor类的417行代码可以发现原因：<img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191217160647.png" alt="QQ截图20191217160647.png"></p>
<p>Java禁止通过反射创建枚举对象。</p>
<p>正是因为枚举类型拥有这些天然的优势，所以用它创建单例是不错的选择，这也是Effective Java推荐的方式。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型实例指定创建对象的种类，通过拷贝这些原型创建新的对象。</p>
<p>适用于：</p>
<ol>
<li>类初始化消耗较多资源；</li>
<li>循环体中生产大量对象的时候。</li>
</ol>
<p>优点：</p>
<ol>
<li>原型模式性能比直接new一个对象性能好；</li>
<li>简化创建对象过程。</li>
</ol>
<p>缺点：</p>
<ol>
<li>对象必须重写Object克隆方法；</li>
<li>复杂对象的克隆方法写起来较麻烦（深克隆、浅克隆）</li>
</ol>
<p>举例：新建一个学生类Student，实现克隆接口，并重写Object的克隆方法（因为都是简单属性，所以浅克隆即可）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在Application中测试一波：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws CloneNotSupportedException &#123;</span><br><span class="line">        Student student &#x3D; new Student();</span><br><span class="line">        ArrayList&lt;Student&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">            Student s &#x3D; (Student) student.clone();</span><br><span class="line">            s.setName(&quot;学生&quot; + i);</span><br><span class="line">            s.setAge(20 + i);</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Student&#123;name&#x3D;&#39;学生0&#39;, age&#x3D;20&#125;, Student&#123;name&#x3D;&#39;学生1&#39;, age&#x3D;21&#125;, Student&#123;name&#x3D;&#39;学生2&#39;, age&#x3D;22&#125;]</span><br></pre></td></tr></table></figure>


<p>这种方式会比直接在循环中创建Student性能好。</p>
<p>当对象包含引用类型属性时，需要使用深克隆，比如Student包含Date属性时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Student implements Cloneable &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private Date birthday;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirthday(Date birthday) &#123;</span><br><span class="line">        this.birthday &#x3D; birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student&#123;&quot; +</span><br><span class="line">                &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">                &quot;, age&#x3D;&quot; + age +</span><br><span class="line">                &quot;, birthday&#x3D;&quot; + birthday +</span><br><span class="line">                &#39;&#125;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Student student &#x3D; (Student) super.clone();</span><br><span class="line">        &#x2F;&#x2F; 引用类型深克隆</span><br><span class="line">        Date birthday &#x3D; (Date) student.getBirthday().clone();</span><br><span class="line">        student.setBirthday(birthday);</span><br><span class="line">        return student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>值得注意的是，克隆会破坏实现了Cloneable接口的单例对象。</p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式又叫门面模式，提供了统一得接口，用来访问子系统中的一群接口。</p>
<p>适用于：</p>
<ol>
<li>子系统越来越复杂，增加外观模式提供简单接口调用；</li>
<li>构建多层系统结构，利用外观对象作为每层的入口，简化层间调用。</li>
</ol>
<p>优点：</p>
<ol>
<li>简化了调用过程，无需了解深入子系统；</li>
<li>减低耦合度；</li>
<li>更好的层次划分；</li>
<li>符合迪米特法则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加子系统，拓展子系统行为容易引入风险；</li>
<li>不符合开闭原则。</li>
</ol>
<p>举个订外卖的例子。</p>
<p>创建一个外卖实体类Takeaway：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Takeaway &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>订外卖过程一般分为三个步骤：下单、支付和配送，所以我们创建三个Service对应这三个过程。新建下单服务OrderService：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class OrderService &#123;</span><br><span class="line"></span><br><span class="line">    public boolean placeAnOrder(Takeaway takeaway) &#123;</span><br><span class="line">        System.out.println(takeaway.getName() + &quot;下单成功&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建支付服务PayService：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class PayService &#123;</span><br><span class="line"></span><br><span class="line">    public boolean pay(Takeaway takeaway) &#123;</span><br><span class="line">        System.out.println(&quot;商品&quot; + takeaway.getName() + &quot;支付成功&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建配送服务DeliveryService：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DeliveryService &#123;</span><br><span class="line"></span><br><span class="line">    public void delivery(Takeaway takeaway) &#123;</span><br><span class="line">        System.out.println(takeaway.getName() + &quot;已由骑手XX接单，订单派送中&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>基于外观模式法则，我们需要创建一个Service来聚合这三个服务，客户端只需要和这个Service交互即可。新建外卖服务TakeawayService：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TakeawayService &#123;</span><br><span class="line"></span><br><span class="line">    private OrderService orderService &#x3D; new OrderService();</span><br><span class="line">    private PayService payService &#x3D; new PayService();</span><br><span class="line">    private DeliveryService deliveryService &#x3D; new DeliveryService();</span><br><span class="line"></span><br><span class="line">    public void takeOrder(Takeaway takeaway) &#123;</span><br><span class="line">        if (orderService.placeAnOrder(takeaway)) &#123;</span><br><span class="line">            if (payService.pay(takeaway)) &#123;</span><br><span class="line">                deliveryService.delivery(takeaway);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建个客户端测试一波：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Takeaway takeaway &#x3D; new Takeaway();</span><br><span class="line">        takeaway.setName(&quot;泡椒🐸&quot;);</span><br><span class="line"></span><br><span class="line">        TakeawayService takeawayService &#x3D; new TakeawayService();</span><br><span class="line">        takeawayService.takeOrder(takeaway);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到，客户端只需要调用TakeawayService即可，无需关系内部具体经历了多少个步骤，运行main方法输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">泡椒🐸下单成功</span><br><span class="line">商品泡椒🐸支付成功</span><br><span class="line">泡椒🐸已由骑手XX接单，订单派送中</span><br></pre></td></tr></table></figure>


<p>该例子的UML图如下所示：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191218151629.png" alt="QQ截图20191218151629.png"></p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>在不改变原有对象的基础之上，将功能附加到对象上，提供了比继承更有弹性的替代方案。</p>
<p>适用于：</p>
<ol>
<li>拓展一个类的功能；</li>
<li>动态给对象添加功能，并且动态撤销。</li>
</ol>
<p>优点：</p>
<ol>
<li>继承的有力补充，不改变原有对象的情况下给对象拓展功能；</li>
<li>通过使用不同的装饰类、不同的组合方式，实现不同的效果。</li>
<li>符合开闭原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加程序复杂性；</li>
</ol>
<p>举个水果沙拉的例子。</p>
<p>比如在点水果沙拉外卖时，可以往水果沙拉里加各种水果，价格也会相应的调整，要让程序支持不同水果自由组合，并计算相应的价格，则可以使用装饰者模式来完成。</p>
<p>定义一个抽象的水果沙拉类AbstractFruitSalad：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractFruitSalad &#123;</span><br><span class="line">    public abstract String remark();</span><br><span class="line">    public abstract int price();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>包含备注和价格抽象方法。</p>
<p>接着创建一个抽象的装饰器AbstractDecorator（关键点，继承抽象水果沙拉类）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AbstractDecorator extends AbstractFruitSalad&#123;</span><br><span class="line"></span><br><span class="line">    private AbstractFruitSalad fruitSalad;</span><br><span class="line"></span><br><span class="line">    public AbstractDecorator(AbstractFruitSalad fruitSalad)&#123;</span><br><span class="line">        this.fruitSalad &#x3D; fruitSalad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String remark() &#123;</span><br><span class="line">        return fruitSalad.remark();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int price() &#123;</span><br><span class="line">        return fruitSalad.price();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建具体的水果沙拉类FruitSalad：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class FruitSalad extends AbstractFruitSalad&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String remark() &#123;</span><br><span class="line">        return &quot;水果🥗（标准）\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int price() &#123;</span><br><span class="line">        return 9;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>该沙拉是标准的水果沙拉，价格是9元。</p>
<p>如果我们的水果沙拉还允许客户添加猕猴桃和西瓜，那么我们可以添加两个新的装饰器。添加猕猴桃装饰器KiwiDecorator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class KiwiDecorator extends AbstractDecorator &#123;</span><br><span class="line"></span><br><span class="line">    public KiwiDecorator(AbstractFruitSalad fruitSalad) &#123;</span><br><span class="line">        super(fruitSalad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String remark() &#123;</span><br><span class="line">        return super.remark() + &quot;加份🥝切\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int price() &#123;</span><br><span class="line">        return super.price() + 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到，加一份猕猴桃需要在原有基础上加2元。</p>
<p>接着继续创建西瓜装饰器WaterMelonDecorator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class WaterMelonDecorator extends AbstractDecorator &#123;</span><br><span class="line"></span><br><span class="line">    public WaterMelonDecorator(AbstractFruitSalad fruitSalad) &#123;</span><br><span class="line">        super(fruitSalad);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String remark() &#123;</span><br><span class="line">        return super.remark() + &quot;加份🍉切\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int price() &#123;</span><br><span class="line">        return super.price() + 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后创建客户端Application测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 点了份水果沙拉，并加了两份🥝和一份🍉，看看最终价格是多少？</span><br><span class="line">        AbstractFruitSalad fruitSalad &#x3D; new FruitSalad();</span><br><span class="line">        fruitSalad &#x3D; new KiwiDecorator(fruitSalad);</span><br><span class="line">        fruitSalad &#x3D; new KiwiDecorator(fruitSalad);</span><br><span class="line">        fruitSalad &#x3D; new WaterMelonDecorator(fruitSalad);</span><br><span class="line"></span><br><span class="line">        System.out.println(fruitSalad.remark() + &quot;价格是：&quot; + fruitSalad.price());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的写法也可以改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 点了份水果沙拉，并加了两份🥝和一份🍉，看看最终价格是多少？</span><br><span class="line">        AbstractFruitSalad fruitSalad &#x3D; new FruitSalad();</span><br><span class="line">        fruitSalad &#x3D; new WaterMelonDecorator(new KiwiDecorator(new KiwiDecorator(fruitSalad)));</span><br><span class="line"></span><br><span class="line">        System.out.println(fruitSalad.remark() + &quot;价格是：&quot; + fruitSalad.price());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">水果🥗（标准）</span><br><span class="line">加份🥝切</span><br><span class="line">加份🥝切</span><br><span class="line">加份🍉切</span><br><span class="line">价格是：16</span><br></pre></td></tr></table></figure>


<p>通过不同的装饰器自由组合，我们可以灵活的组装出各式各样的水果沙拉，这正是装饰者模式的优点，但明显可以看出代码变复杂了。</p>
<p>这个例子的UML图如下所示:</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191218172739.png" alt="QQ截图20191218172739.png"></p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个类的接口转换为期望的另一个接口，使原本不兼容的类可以一起工作。</p>
<p>适用于：</p>
<ol>
<li>已存在的类，它的方法和需求不匹配时（方法结果相同或者相似）</li>
</ol>
<p>优点:</p>
<ol>
<li>提高类的透明性和复用，现有的类复用但不需改变；</li>
<li>目标类和适配器类解耦，提高程序拓展性；</li>
<li>符合开闭原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>适配器编写过程需要全面考虑，可能会增加系统的复杂性；</li>
<li>降低代码可读性。</li>
</ol>
<p>分为：类适配器模式和对象适配器模式。</p>
<p>先举个类适配器模式的例子：</p>
<p>假如项目里原有一条水果的产品线，比如包含一个树莓类Raspberry：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Raspberry &#123;</span><br><span class="line"></span><br><span class="line">    public void addRaspberry() &#123;</span><br><span class="line">        System.out.println(&quot;添加点树莓&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>随着项目的拓展，现在新增了水果派产品线，新建Pie接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Pie &#123;</span><br><span class="line"></span><br><span class="line">    void make();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>要将Raspberry加入到Pie产品线，又不想修改Raspberry类的代码，则可以创建一个适配器RaspberryPieAdaptor：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class RaspberryPieAdaptor extends Raspberry implements Pie&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        System.out.println(&quot;制作一个派🥧&quot;);</span><br><span class="line">        super.addRaspberry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>适配器继承被适配的类，实现新的产品线接口。</p>
<p>在Application里测试一波：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Pie pie &#x3D; new RaspberryPieAdaptor();</span><br><span class="line">        pie.make();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">制作一个派🥧</span><br><span class="line">添加点树莓</span><br></pre></td></tr></table></figure>


<p>成功通过适配器制造了树莓派。类适配器模式的UML图很简单：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191219105058.png" alt="QQ截图20191219105058.png"></p>
<p>对象适配器模式只需要将RaspberryPieAdaptor修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class RaspberryPieAdaptor implements Pie&#123;</span><br><span class="line"></span><br><span class="line">    private Raspberry raspberry &#x3D; new Raspberry();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        System.out.println(&quot;制作一个派🥧&quot;);</span><br><span class="line">        raspberry.addRaspberry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这种模式不直接继承被适配者，而是在适配器里创建被适配者。这种模式的UML图：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191219110730.png" alt="QQ截图20191219110730.png"></p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>提供了减少对象数量从而改善应用所需的对象结构的方式，运用共享技术有效地支持大量细粒度的对象。</p>
<p>适用于：</p>
<ol>
<li>底层系统开发，解决性能问题；</li>
<li>系统拥有大量相似对象，需要缓冲池的场景。</li>
</ol>
<p>优点：</p>
<ol>
<li>减少对象的创建，降低内存占用；</li>
</ol>
<p>缺点：</p>
<ol>
<li>关注内/外部状态，关注线程安全问题；</li>
<li>程序的逻辑复杂化。</li>
</ol>
<p>内部状态：简单理解为享元对象的属性状态，不会因为外部的改变而改变； 外部状态：简单理解为方法参数。</p>
<p>举个例子，新建派🥧接口Pie：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Pie &#123;</span><br><span class="line"></span><br><span class="line">    void make() throws InterruptedException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其实现类水果派FruitPie：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class FruitPie implements Pie &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private LocalDateTime productTime;</span><br><span class="line"></span><br><span class="line">    public FruitPie(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductTime(LocalDateTime productTime) &#123;</span><br><span class="line">        this.productTime &#x3D; productTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void make() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            System.out.println(name + &quot;生产时间：&quot; + this.productTime);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>包含名称和生产日期属性，并且有个make方法。</p>
<p>接着创建生产FruitPie的工厂FruitPieFactory：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class FruitPieFactory &#123;</span><br><span class="line"></span><br><span class="line">    private static final HashMap&lt;String, FruitPie&gt; PIE_HASH_MAP &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static FruitPie produce(String name) &#123;</span><br><span class="line">        FruitPie fruitPie &#x3D; PIE_HASH_MAP.get(name);</span><br><span class="line">        if (fruitPie &#x3D;&#x3D; null) &#123;</span><br><span class="line">            System.out.println(&quot;没有&quot; + name + &quot;制作方法，学习制作...&quot;);</span><br><span class="line">            fruitPie &#x3D; new FruitPie(name);</span><br><span class="line">            PIE_HASH_MAP.put(name, fruitPie);</span><br><span class="line">        &#125;</span><br><span class="line">        return fruitPie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>代码关键是通过HashMap存储对象。</p>
<p>编写个测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    private static final String[] PIE &#x3D; &#123;&quot;🍇派&quot;, &quot;🍈派&quot;, &quot;🍓派&quot;, &quot;🍒派&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IntStream.range(0, 10).forEach((i) -&gt; &#123;</span><br><span class="line">            String name &#x3D; PIE[(int) (Math.random() * PIE.length)];</span><br><span class="line">            FruitPie fruitPie &#x3D; FruitPieFactory.produce(name);</span><br><span class="line">            fruitPie.setProductTime(LocalDateTime.now());</span><br><span class="line">            fruitPie.make();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">没有🍓派制作方法，学习制作...</span><br><span class="line">🍓派生产时间：2019-12-19T16:13:26.397</span><br><span class="line">没有🍇派制作方法，学习制作...</span><br><span class="line">🍇派生产时间：2019-12-19T16:13:26.498</span><br><span class="line">🍇派生产时间：2019-12-19T16:13:26.599</span><br><span class="line">没有🍒派制作方法，学习制作...</span><br><span class="line">🍒派生产时间：2019-12-19T16:13:26.700</span><br><span class="line">🍒派生产时间：2019-12-19T16:13:26.800</span><br><span class="line">🍒派生产时间：2019-12-19T16:13:26.901</span><br><span class="line">没有🍈派制作方法，学习制作...</span><br><span class="line">🍈派生产时间：2019-12-19T16:13:27.002</span><br><span class="line">🍓派生产时间：2019-12-19T16:13:27.103</span><br><span class="line">🍇派生产时间：2019-12-19T16:13:27.203</span><br><span class="line">🍇派生产时间：2019-12-19T16:13:27.304</span><br></pre></td></tr></table></figure>


<p>从结果看，在10次循环中，只生产了4个对象，这很好的描述了系统有大量相似对象，需要缓冲池的场景。</p>
<p>JDK中的字符串常量池，数据库连接池等都是用的享元模式。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使客户端对单个对象和组合对象保持一致的方式处理。</p>
<p>适用于：</p>
<ol>
<li>客户端可以忽略组合对象与单个对象的差异；</li>
<li>处理树形结构数据。</li>
</ol>
<p>优点:</p>
<ol>
<li>层次清晰；</li>
<li>客户端不必关系层次差异，方便控制；</li>
<li>符合开闭原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>树形处理较为复杂。</li>
</ol>
<p>举个菜单按钮组成的树形例子。</p>
<p>新建菜单按钮的组合抽象类AbstractMenuButton：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractMenuButton &#123;</span><br><span class="line"></span><br><span class="line">    public void add(AbstractMenuButton abstractMenuButton) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持创建操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持名称获取&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持类型获取&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getIcon() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持图标&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void print() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;不支持打印操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>组合了菜单按钮操作的基本方法。</p>
<p>新增按钮类Button：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Button extends AbstractMenuButton &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Button(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;按钮&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(getName() + &quot;【&quot; + getType() + &quot;】&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>按钮拥有名称属性，并且支持名称获取，类型获取和打印方法，所以重写了这三个父类方法。</p>
<p>接着新建菜单类Menu：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public class Menu extends AbstractMenuButton &#123;</span><br><span class="line"></span><br><span class="line">    private List&lt;AbstractMenuButton&gt; items &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    private String name;</span><br><span class="line">    private String icon;</span><br><span class="line">    private Integer level;</span><br><span class="line"></span><br><span class="line">    public Menu(String name, String icon, Integer level) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.icon &#x3D; icon;</span><br><span class="line">        this.level &#x3D; level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void add(AbstractMenuButton abstractMenuButton) &#123;</span><br><span class="line">        items.add(abstractMenuButton);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return &quot;菜单&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getIcon() &#123;</span><br><span class="line">        return this.icon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void print() &#123;</span><br><span class="line">        System.out.println(getIcon() + getName() + &quot;【&quot; + getType() + &quot;】&quot;);</span><br><span class="line">        for (AbstractMenuButton item : items) &#123;</span><br><span class="line">            if (this.level !&#x3D; null) &#123;</span><br><span class="line">                for (int i &#x3D; 0; i &lt; this.level; i++) &#123;</span><br><span class="line">                    System.out.print(&quot;    &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            item.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>菜单包含名称、图标和层级属性，并且菜单可以包含下级（比如下级菜单，下级按钮），所以它包含一个List类型的属性items。</p>
<p>此外，菜单包含添加下级、名称获取、类型获取、图标获取和打印方法。</p>
<p>新建一个客户端，测试菜单按钮的层级结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Menu userMenu &#x3D; new Menu(&quot;用户管理&quot;, &quot;🧑&quot;, 2);</span><br><span class="line">        Button createUser &#x3D; new Button(&quot;新增用户&quot;);</span><br><span class="line">        Button updateUser &#x3D; new Button(&quot;修改用户&quot;);</span><br><span class="line">        Button deleteUser &#x3D; new Button(&quot;删除用户&quot;);</span><br><span class="line">        userMenu.add(createUser);</span><br><span class="line">        userMenu.add(updateUser);</span><br><span class="line">        userMenu.add(deleteUser);</span><br><span class="line"></span><br><span class="line">        Menu logMenu &#x3D; new Menu(&quot;操作日志&quot;, &quot;📃&quot;, 2);</span><br><span class="line">        Button export &#x3D; new Button(&quot;导出Excel&quot;);</span><br><span class="line">        logMenu.add(export);</span><br><span class="line"></span><br><span class="line">        Menu systemMenu &#x3D; new Menu(&quot;系统管理&quot;, &quot;🔨&quot;, 1);</span><br><span class="line">        systemMenu.add(userMenu);</span><br><span class="line">        systemMenu.add(logMenu);</span><br><span class="line"></span><br><span class="line">        systemMenu.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>打印输出如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">🔨系统管理【菜单】</span><br><span class="line">    🧑用户管理【菜单】</span><br><span class="line">        新增用户【按钮】</span><br><span class="line">        修改用户【按钮】</span><br><span class="line">        删除用户【按钮】</span><br><span class="line">    📃操作日志【菜单】</span><br><span class="line">        导出Excel【按钮】</span><br></pre></td></tr></table></figure>


<p>UML图如下所示：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191219190427.png" alt="QQ截图20191219190427.png"></p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>将抽象部分和具体实现部分分离，使它们都可以独立变化。通过组合的方式建立两个类之间的关系，而不是通过继承。</p>
<p>适用于：</p>
<ol>
<li>抽象和实体实现之间增加更多的灵活性；</li>
<li>一个类存在多个独立变化的维度，并且需要独立拓展；</li>
<li>不希望使用继承。</li>
</ol>
<p>优点：</p>
<ol>
<li>分离抽象部分和具体实现部分；</li>
<li>提高了系统可拓展性；</li>
<li>符合开闭原则和合成复用原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>增加了系统的理解和设计难度；</li>
</ol>
<p>举个例子：</p>
<p>现有派的接口类Pie：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface Pie &#123;</span><br><span class="line"></span><br><span class="line">    Pie makePie();</span><br><span class="line"></span><br><span class="line">    void getType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>包含制作派和获取派类型抽象方法。</p>
<p>接着创建两个Pie的实现类，苹果派AppliePie：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ApplePie implements Pie &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Pie makePie() &#123;</span><br><span class="line">        System.out.println(&quot;制作苹果派🍎🥧&quot;);</span><br><span class="line">        return new ApplePie();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getType() &#123;</span><br><span class="line">        System.out.println(&quot;水果派&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>胡萝卜派CarrotPie：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class CarrotPie implements Pie&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Pie makePie() &#123;</span><br><span class="line">        System.out.println(&quot;制作胡萝卜派🥕🥧&quot;);</span><br><span class="line">        return new CarrotPie();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getType() &#123;</span><br><span class="line">        System.out.println(&quot;蔬菜沙拉派&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>接着创建一个店铺抽象类Store，通过属性的方式和Pie相关联，目的是可以在不同的店铺实现类中灵活地制作各种派：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Store &#123;</span><br><span class="line"></span><br><span class="line">    protected Pie pie;</span><br><span class="line"></span><br><span class="line">    public Store(Pie pie)&#123;</span><br><span class="line">        this.pie &#x3D; pie;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    abstract Pie makePie();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Store子类之一，山姆大叔的小店SamStore：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SamStore extends Store&#123;</span><br><span class="line"></span><br><span class="line">    public SamStore(Pie pie) &#123;</span><br><span class="line">        super(pie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Pie makePie() &#123;</span><br><span class="line">        System.out.print(&quot;山姆大叔的小店💒&quot;);</span><br><span class="line">        return pie.makePie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Store子类之二，杰克的小店JackStore：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class JackStore extends Store &#123;</span><br><span class="line"></span><br><span class="line">    public JackStore(Pie pie) &#123;</span><br><span class="line">        super(pie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Pie makePie() &#123;</span><br><span class="line">        System.out.print(&quot;杰克的小店💒&quot;);</span><br><span class="line">        return pie.makePie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新建一个客户端，测试Pie的实现类和Store的继承类之间的自由组合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Store samStore &#x3D; new SamStore(new ApplePie());</span><br><span class="line">        Pie samStorePie &#x3D; samStore.makePie();</span><br><span class="line">        samStorePie.getType();</span><br><span class="line"></span><br><span class="line">        Store jackStore &#x3D; new JackStore(new CarrotPie());</span><br><span class="line">        Pie jackStorePie &#x3D; jackStore.makePie();</span><br><span class="line">        jackStorePie.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">山姆大叔的小店💒制作苹果派🍎🥧</span><br><span class="line">水果派</span><br><span class="line">杰克的小店💒制作胡萝卜派🥕🥧</span><br><span class="line">蔬菜沙拉派</span><br></pre></td></tr></table></figure>


<p>这个例子很好地体现了桥接模式的特点，UML图如下：</p>
<p><img src="https://mrbird.cc/img/QQ%E6%88%AA%E5%9B%BE20191220151943.png" alt="QQ截图20191220151943.png"></p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>为其他对象提供一种代理，以控制对这个对象的访问，代理对象在客户端和目标对象之间起到了中介的作用。</p>
<p>适用于：</p>
<ol>
<li>保护目标对象；</li>
<li>增强目标对象。</li>
</ol>
<p>优点：</p>
<ol>
<li>将代理对象和真实被调用的目标对象分离；</li>
<li>降低耦合，拓展性好；</li>
<li>保护目标对象，增强目标对象。</li>
</ol>
<p>缺点：</p>
<ol>
<li>造成类的数目增加，增加复杂度；</li>
<li>客户端和目标对象增加代理对象，会造成处理速度变慢。</li>
</ol>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>通过在代码中显式地定义了一个代理类，在代理类中通过同名的方法对目标对象的方法进行包装，客户端通过调用代理类的方法来调用目标对象的方法。</p>
<p>举个静态代理的例子：</p>
<p>新建一个派的制作接口PieService：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PieServcie &#123;</span><br><span class="line">    void makePie();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建其实现类PieServiceImpl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class PieServiceImpl implements PieServcie&#123;</span><br><span class="line">    public void makePie() &#123;</span><br><span class="line">        System.out.println(&quot;制作🥗派&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>要对PieServiceImpl的<code>makePie</code>方法增强，我们需要创建一个代理对象PieServiceProxy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class PieServiceProxy &#123;</span><br><span class="line"></span><br><span class="line">    private PieServcie pieServcie;</span><br><span class="line"></span><br><span class="line">    public void makePie() &#123;</span><br><span class="line">        beforeMethod();</span><br><span class="line">        pieServcie &#x3D; new PieServiceImpl();</span><br><span class="line">        pieServcie.makePie();</span><br><span class="line">        afterMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void beforeMethod() &#123;</span><br><span class="line">        System.out.println(&quot;准备材料&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void afterMethod() &#123;</span><br><span class="line">        System.out.println(&quot;保鲜&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在PieServiceProxy中我们创建了一个和PieServcie一致的同名方法<code>makePie</code>，方法内部调用了PieServiceImpl的<code>makePie</code>方法，并且在方法调用前调用了代理类的<code>beforeMethod</code>方法，方法调用后调用了代理类的<code>afterMethod</code>方法。</p>
<p>创建客户端Application，测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PieServiceProxy proxy &#x3D; new PieServiceProxy();</span><br><span class="line">        proxy.makePie();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">准备材料</span><br><span class="line">制作🥗派</span><br><span class="line">保鲜</span><br></pre></td></tr></table></figure>


<p>这个例子的UML图如下：</p>
<p><img src="https://mrbird.cc/img/QQ20200421-100633@2x.png" alt="QQ20200421-100633@2x"></p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>JDK的动态代理只能代理接口，通过接口的方法名在动态生成的代理类中调用业务实现类的同名方法。</p>
<p>静态代理的缺点就是每需要代理一个类，就需要手写对应的代理类。这个问题可以用动态代理来解决。举个动态代理的例子：</p>
<p>新建冰淇淋制作接口IceCreamService：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface IceCreamService &#123;</span><br><span class="line">    void makeIceCream(String fruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实现类IceCreamServiceImpl：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class IceCreamServiceImpl implements IceCreamService &#123;</span><br><span class="line"></span><br><span class="line">    public void makeIceCream(String fruit) &#123;</span><br><span class="line">        System.out.println(&quot;制作&quot; + fruit + &quot;🍦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在需要对IceCreamServiceImpl进行代理增强，如果使用静态代理，我们需要编写一个IceCreamServiceImplProxy类，使用动态代理的话，我们可以动态生成对应的代理类。</p>
<p>创建DynamicProxy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理的目标对象</span><br><span class="line">    private Object object;</span><br><span class="line"></span><br><span class="line">    public DynamicProxy(Object object) &#123;</span><br><span class="line">        this.object &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object proxy() &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; object.getClass();</span><br><span class="line">        &#x2F;&#x2F; 生成代理对象</span><br><span class="line">        return Proxy.newProxyInstance(clazz.getClassLoader(),</span><br><span class="line">                clazz.getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param proxy  动态生成的代理对象</span><br><span class="line">     * @param method 代理方法</span><br><span class="line">     * @param args   代理方法的方法参数</span><br><span class="line">     * @return 结果</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">       return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>动态代理类通过实现InvocationHandler的<code>invoke</code>方法实现，<code>proxy</code>用于生成代理对象。剩下的步骤和静态代理类似，完善DynamicProxy：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理的目标对象</span><br><span class="line">    private Object object;</span><br><span class="line"></span><br><span class="line">    public DynamicProxy(Object object) &#123;</span><br><span class="line">        this.object &#x3D; object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object proxy() &#123;</span><br><span class="line">        Class&lt;?&gt; clazz &#x3D; object.getClass();</span><br><span class="line">        &#x2F;&#x2F; 生成代理对象</span><br><span class="line">        return Proxy.newProxyInstance(clazz.getClassLoader(),</span><br><span class="line">                clazz.getInterfaces(), this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param proxy  动态生成的代理对象</span><br><span class="line">     * @param method 代理方法</span><br><span class="line">     * @param args   代理方法的方法参数</span><br><span class="line">     * @return 结果</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        beforeMethod(object);</span><br><span class="line">        &#x2F;&#x2F; 反射执行代理对象的目标方法</span><br><span class="line">        Object result &#x3D; method.invoke(object, args);</span><br><span class="line">        afterMethod(object);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void beforeMethod(Object object) &#123;</span><br><span class="line">        if (object instanceof PieServcie) &#123;</span><br><span class="line">            System.out.println(&quot;准备派的材料&quot;);</span><br><span class="line">        &#125; else if (object instanceof IceCreamService) &#123;</span><br><span class="line">            System.out.println(&quot;准备冰淇淋材料&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;暂不支持代理&quot; + object.getClass() + &quot;类型&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void afterMethod(Object object) &#123;</span><br><span class="line">        if (object instanceof PieServcie) &#123;</span><br><span class="line">            System.out.println(&quot;保鲜派&quot;);</span><br><span class="line">        &#125; else if (object instanceof IceCreamService) &#123;</span><br><span class="line">            System.out.println(&quot;保鲜冰淇淋&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;暂不支持代理&quot; + object.getClass() + &quot;类型&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建客户端Application测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        PieServcie pieServiceDynamicProxy &#x3D; (PieServcie) new DynamicProxy(new PieServiceImpl()).proxy();</span><br><span class="line">        pieServiceDynamicProxy.makePie();</span><br><span class="line">        System.out.println(&quot;-----------------&quot;);</span><br><span class="line">        IceCreamService iceCreamServiceDynamicProxy &#x3D; (IceCreamService) new DynamicProxy(new IceCreamServiceImpl()).proxy();</span><br><span class="line">        iceCreamServiceDynamicProxy.makeIceCream(&quot;🍓&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">准备派的材料</span><br><span class="line">制作🥗派</span><br><span class="line">保鲜派</span><br><span class="line">-----------------</span><br><span class="line">准备冰淇淋材料</span><br><span class="line">制作🍓🍦</span><br><span class="line">保鲜冰淇淋</span><br></pre></td></tr></table></figure>


<p>可以看到，通过动态代理我们实现了目标方法增强，并且不需要手写目标类的代理对象。</p>
<h4 id="CGLib代理"><a href="#CGLib代理" class="headerlink" title="CGLib代理"></a>CGLib代理</h4><p>通过继承来实现，生成的代理类就是目标对象类的子类，通过重写业务方法来实现代理。</p>
<h4 id="Spring对代理模式的拓展"><a href="#Spring对代理模式的拓展" class="headerlink" title="Spring对代理模式的拓展"></a>Spring对代理模式的拓展</h4><ol>
<li>当Bean有实现接口时，使用JDK动态代理；</li>
<li>当Bean没有实现接口时，使用CGLib代理。</li>
</ol>
<p>可以通过以下配置强制使用CGLib代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  aop:</span><br><span class="line">    proxy-target-class: true</span><br></pre></td></tr></table></figure>


<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法模式定义了一个流程的骨架，由多个方法组成。并允许子类为一个或多个步骤提供实现。简而言之就是公共的不变的部分由父类统一实现，变化的部分由子类来个性化实现。</p>
<p>优点：</p>
<ol>
<li>提高复用性；</li>
<li>提高拓展性；</li>
<li>符合开闭原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>类的数目增加；</li>
<li>增加了系统实现的复杂度；</li>
<li>父类添加新的抽象方法，所有子类都要改一遍。</li>
</ol>
<p>举个模板方法模式的例子。定义一个外卖的接口，包含下单、制作和打包配送三个步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Takeaway &#123;</span><br><span class="line"></span><br><span class="line">    final void order() &#123;</span><br><span class="line">        System.out.println(&quot;下单&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void packageSend() &#123;</span><br><span class="line">        System.out.println(&quot;打包派送&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract void make();</span><br><span class="line"></span><br><span class="line">    protected boolean needTableware() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final void flow() &#123;</span><br><span class="line">        this.order();</span><br><span class="line">        this.make();</span><br><span class="line">        if (needTableware()) &#123;</span><br><span class="line">            System.out.println(&quot;赠送一次性餐具&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.packageSend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中下单和打包配送行为是固定的，不同的是制作过程，所以<code>order</code>和<code>packageSend</code>方法提供了默认实现，并且由final修饰，子类不可重写。此外，我们还可以通过<code>needTableware</code>这个钩子方法来控制某些子类的定制化需求。</p>
<p>新增BarbecueTakeaway继承Takeaway：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class BarbecueTakeaway extends Takeaway &#123;</span><br><span class="line"></span><br><span class="line">    private final boolean needTableware;</span><br><span class="line"></span><br><span class="line">    public BarbecueTakeaway(boolean needTableware) &#123;</span><br><span class="line">        this.needTableware &#x3D; needTableware;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void make() &#123;</span><br><span class="line">        System.out.println(&quot;制作烤肉&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean needTableware() &#123;</span><br><span class="line">        return this.needTableware;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新增FruitTakeaway继承Takeaway：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class FruitTakeaway extends Takeaway &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void make() &#123;</span><br><span class="line">        System.out.println(&quot;水果配货&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected boolean needTableware() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>新增个客户端Application测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Takeaway barbecue &#x3D; new BarbecueTakeaway(true);</span><br><span class="line">        barbecue.flow();</span><br><span class="line"></span><br><span class="line">        FruitTakeaway fruit &#x3D; new FruitTakeaway();</span><br><span class="line">        fruit.flow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下单</span><br><span class="line">制作烤肉</span><br><span class="line">赠送一次性餐具</span><br><span class="line">打包派送</span><br><span class="line">下单</span><br><span class="line">水果配货</span><br><span class="line">打包派送</span><br></pre></td></tr></table></figure>
<p>UML：</p>
<p><img src="https://mrbird.cc/img/QQ20200421-153516@2x.png" alt="QQ20200421-153516@2x"></p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>ignore</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化不会影响到使用算法的用户。策略模式常用于消除大量的if else代码。</p>
<p>适用场景：</p>
<ol>
<li>系统有很多类，它们的区别仅仅在于行为不同；</li>
<li>一个系统需要动态地在几种算法中选择一种；</li>
</ol>
<p>举个策略模式的例子（促销活动），定义一个促销策略接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface PromotionStrategy &#123;</span><br><span class="line"></span><br><span class="line">    void promotion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实现类之一（策略之一），满减促销策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class FullReductionPromotionStrategy implements PromotionStrategy &#123;</span><br><span class="line">    public void promotion() &#123;</span><br><span class="line">        System.out.println(&quot;满1000立减1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实现类之一（策略之一），打折促销策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DiscountPromotionStrategy implements PromotionStrategy &#123;</span><br><span class="line">    public void promotion() &#123;</span><br><span class="line">        System.out.println(&quot;9.9折钜惠&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建一个客户端测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟客户端传递的促销策略key</span><br><span class="line">        String promotionKey &#x3D; &quot;fr&quot;;</span><br><span class="line">        PromotionStrategy strategy;</span><br><span class="line">        if (&quot;fr&quot;.equals(promotionKey)) &#123;</span><br><span class="line">            strategy &#x3D; new FullReductionPromotionStrategy();</span><br><span class="line">        &#125; else if (&quot;ds&quot;.equals(promotionKey)) &#123;</span><br><span class="line">            strategy &#x3D; new DiscountPromotionStrategy();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new RuntimeException(&quot;暂不支持该促销活动&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        strategy.promotion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">满1000立减1</span><br></pre></td></tr></table></figure>


<p>策略模式常结合工厂模式来消除大量的if else代码，我们新建一个促销策略的创建工厂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class PromotionStrategyFactory &#123;</span><br><span class="line"></span><br><span class="line">    private static final Map&lt;String, PromotionStrategy&gt; PROMOTION_STRATEGY_MAP &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private static final PromotionStrategy NON_PROMOTION &#x3D; () -&gt; System.out.println(&quot;无促销活动&quot;);</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.FR, new FullReductionPromotionStrategy());</span><br><span class="line">        PROMOTION_STRATEGY_MAP.put(PromotionKey.DS, new DiscountPromotionStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private PromotionStrategyFactory() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static PromotionStrategy getPromotionStrategy(String promotionKey) &#123;</span><br><span class="line">        PromotionStrategy strategy &#x3D; PROMOTION_STRATEGY_MAP.get(promotionKey);</span><br><span class="line">        return strategy &#x3D;&#x3D; null ? NON_PROMOTION : strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private interface PromotionKey &#123;</span><br><span class="line">        String FR &#x3D; &quot;fr&quot;;</span><br><span class="line">        String DS &#x3D; &quot;ds&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码中，我们通过Map来装载促销策略，这样可以减少对象的重复创建。如果不希望在static块中一次性初始化所有促销策略，我们可以结合享元模式来推迟对象创建过程。</p>
<p>通过这个工厂方法，上面客户端代码可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 模拟客户端传递的促销策略key</span><br><span class="line">        String promotionKey &#x3D; &quot;fr&quot;;</span><br><span class="line">        PromotionStrategy promotionStrategy &#x3D; PromotionStrategyFactory.getPromotionStrategy(promotionKey);</span><br><span class="line">        promotionStrategy.promotion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><p>用的较少，暂不记录。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式定义了对象之间的一对多依赖，让多个观察者同时监听某个主题对象，当主体对象发生变化时，它的所有观察者都会收到响应的通知。</p>
<p>优点：</p>
<ol>
<li>观察者和被观察者之间建立一个抽象的耦合；</li>
<li>观察者模式支持广播通信。</li>
</ol>
<p>缺点：</p>
<ol>
<li>观察者之间有过多的细节依赖，提高时间消耗及程序复杂度；</li>
<li>应避免循环调用。</li>
</ol>
<p>JDK对观察者模式提供了支持。下面举个观察者模式的例子。</p>
<p>创建一个博客类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 继承 Observable类，Blog为被观察对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Blog extends Observable &#123;</span><br><span class="line"></span><br><span class="line">    private String title;</span><br><span class="line"></span><br><span class="line">    public Blog(String title) &#123;</span><br><span class="line">        this.title &#x3D; title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void comment(Comment comment) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(comment.getNickname() + &quot;评论了&lt;&quot; + this.title + &quot;&gt; ，&quot; +</span><br><span class="line">                &quot;评论内容：&quot; + comment.getValue());</span><br><span class="line">        &#x2F;&#x2F; 设置标识位 changed &#x3D; true，表示被观察者发生了改变</span><br><span class="line">        setChanged();</span><br><span class="line">        &#x2F;&#x2F; 通知观察者，可以给观察者传递数据</span><br><span class="line">        notifyObservers(comment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Comment类代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Comment &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 评论者昵称</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String nickname;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 评论内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String value;</span><br><span class="line"></span><br><span class="line">    public Comment(String nickname, String value) &#123;</span><br><span class="line">        this.nickname &#x3D; nickname;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getNickname() &#123;</span><br><span class="line">        return nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Blog类是被观察者对象，被观察者对象需要继承JDK的Observable类，继承后，被观察者对象包含如下属性和方法：</p>
<p><img src="https://mrbird.cc/img/QQ20200511-093515@2x.png" alt="QQ20200511-093515@2x"></p>
<p>这些方法都是线程安全方法（加了synchronized同步锁）。</p>
<p>Blog的comment方法中，当博客收到评论时，首先调用父类的setChanged()方法，设置标识位 changed = true，表示被观察者发生了改变；然后调用父类的notifyObservers(Object)方法通知所有观察者。</p>
<p>被观察者对象创建好后，我们接着创建观察者。新建一个Author类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Author implements Observer &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Author(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 观察者被通知后，就会调用这个方法</span><br><span class="line">     *</span><br><span class="line">     * @param o   被观察者对象</span><br><span class="line">     * @param arg 被观察者传递过来的数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void update(Observable o, Object arg) &#123;</span><br><span class="line">        Blog blog &#x3D; (Blog) o;</span><br><span class="line">        Comment comment &#x3D; (Comment) arg;</span><br><span class="line">        System.out.println(&quot;系统感知到&quot; + this.name + &quot;撰写的博文&lt;&quot; +</span><br><span class="line">                blog.getTitle() + &quot;&gt;收到了&quot; + comment.getNickname() +</span><br><span class="line">                &quot;的评论，评论内容为：&quot; + comment.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>观察者对象需要实现JDK的Observer类，重写update方法。当被观察者对象调用了notifyObservers方法后，相应的观察者的update方法会被调用。</p>
<p>新建一个客户端测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Blog blog &#x3D; new Blog(&quot;Java从入门到放弃&quot;);</span><br><span class="line">        Author author &#x3D; new Author(&quot;MrBird&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 添加观察者</span><br><span class="line">        blog.addObserver(author);</span><br><span class="line"></span><br><span class="line">        Comment comment &#x3D; new Comment(&quot;Scott&quot;,</span><br><span class="line">                &quot;感谢楼主的文章，让我及时放弃Java，回家继承了千万家产。&quot;);</span><br><span class="line">        blog.comment(comment);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scott评论了&lt;Java从入门到放弃&gt; ，评论内容：感谢楼主的文章，让我及时放弃Java，回家继承了千万家产。</span><br><span class="line">系统感知到MrBird撰写的博文&lt;Java从入门到放弃&gt;收到了Scott的评论，评论内容为：感谢楼主的文章，让我及时放弃Java，回家继承了千万家产。</span><br></pre></td></tr></table></figure>


<p>值得注意的是，观察者的update方法里的逻辑最好进行异步化，这样在并发环境下可以提升程序性能。</p>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/jimoer/p/9537997.html%E3%80%82">https://www.cnblogs.com/jimoer/p/9537997.html。</a></p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>暂不记录。</p>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>暂不记录。</p>
<h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><p>职责链模式为请求创建一个接收此次请求对象的链。</p>
<p>适用于：</p>
<ul>
<li>一个请求的处理需要多个对象当中的一个或几个协作处理；</li>
</ul>
<p>优点：</p>
<ol>
<li>请求的发送者和接受者（请求的处理）解耦；</li>
<li>职责链可以动态的组合。</li>
</ol>
<p>缺点：</p>
<ol>
<li>职责链太长或者处理时间过长，影响性能；</li>
<li>职责链可能过多。</li>
</ol>
<p>举个字符串校验的例子。新建一个字符串校验抽象类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public abstract class StringValidator &#123;</span><br><span class="line"></span><br><span class="line">    protected StringValidator validator;</span><br><span class="line"></span><br><span class="line">    public void setNextValidator(StringValidator validator) &#123;</span><br><span class="line">        this.validator &#x3D; validator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void check(String value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>StringValidator类包含了一个自身类型的成员变量，这也是该模式的设计核心，以此形成链条。</p>
<p>创建一个校验字符串长度的类StringLengthValidator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StringLengthValidator extends StringValidator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void check(String value) &#123;</span><br><span class="line">        if (value !&#x3D; null &amp;&amp; value.length() !&#x3D; 0) &#123;</span><br><span class="line">            System.out.println(&quot;字符串长度合法&quot;);</span><br><span class="line">            if (validator !&#x3D; null) &#123;</span><br><span class="line">                validator.check(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;字符串长度不合法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码中，在字符串长度校验合法后，我们判断父类的validator属性是否为空，不为空则调用其check方法继续下一步校验。</p>
<p>接着再新建一个校验字符串内容的类StringValueValidator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StringValueValidator extends StringValidator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void check(String value) &#123;</span><br><span class="line">        if (value.contains(&quot;fuck&quot;)) &#123;</span><br><span class="line">            System.out.println(&quot;字符串值不合法&quot;);</span><br><span class="line">            if (validator !&#x3D; null) &#123;</span><br><span class="line">                validator.check(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;字符串值合法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>套路和StringLengthValidator一样。接着创建一个客户端类，演示下如何让校验类形成一个链条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StringValidator lengthValidator &#x3D; new StringLengthValidator();</span><br><span class="line">        StringValidator valueValidator &#x3D; new StringValueValidator();</span><br><span class="line"></span><br><span class="line">        lengthValidator.setNextValidator(valueValidator);</span><br><span class="line">        lengthValidator.check(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面代码中，通过StringValidator的setNextValidator方法，我们可以指定下一个校验类，以此形成链条，程序输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串长度合法</span><br><span class="line">字符串值合法</span><br></pre></td></tr></table></figure>


<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>暂不记录🌚</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>暂不记录🌚</p>
<blockquote>
<p>参考连接：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2021/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">http://example.com/2021/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/12/01/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Spring源码</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">Java设计模式学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.1.</span> <span class="toc-text">懒汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E5%90%8C%E6%AD%A5%E9%94%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">双重同步锁单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.3.</span> <span class="toc-text">静态内部类单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%BF%E6%B1%89%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.4.</span> <span class="toc-text">饿汉单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.5.</span> <span class="toc-text">序列化破坏单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.6.</span> <span class="toc-text">反射破坏单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.7.</span> <span class="toc-text">枚举单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">原型模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">外观模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">装饰者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">适配器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">享元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.7.1.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">3.7.2.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CGLib%E4%BB%A3%E7%90%86"><span class="toc-number">3.7.3.</span> <span class="toc-text">CGLib代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring%E5%AF%B9%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%8B%93%E5%B1%95"><span class="toc-number">3.7.4.</span> <span class="toc-text">Spring对代理模式的拓展</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">模板方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">迭代器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.</span> <span class="toc-text">解释器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.6.</span> <span class="toc-text">备忘录模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">中介者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.9.</span> <span class="toc-text">职责链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.10.</span> <span class="toc-text">访问者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.11.</span> <span class="toc-text">状态模式</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Java设计模式"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java设计模式"/></a><div class="content"><a class="title" href="/2021/12/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="Java设计模式">Java设计模式</a><time datetime="2021-11-30T16:02:17.000Z" title="Created 2021-12-01 00:02:17">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/01/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring源码"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring源码"/></a><div class="content"><a class="title" href="/2021/12/01/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Spring源码">Spring源码</a><time datetime="2021-11-30T16:02:17.000Z" title="Created 2021-12-01 00:02:17">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/01/Docker/" title="Docker"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2021/12/01/Docker/" title="Docker">Docker</a><time datetime="2021-11-30T16:02:17.000Z" title="Created 2021-12-01 00:02:17">2021-12-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/04/15/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="ElasticSearch基本操作"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch基本操作"/></a><div class="content"><a class="title" href="/2021/04/15/ElasticSearch%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="ElasticSearch基本操作">ElasticSearch基本操作</a><time datetime="2021-04-15T14:33:54.000Z" title="Created 2021-04-15 22:33:54">2021-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/03/10/JSON%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96/" title="JSON对象转化"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JSON对象转化"/></a><div class="content"><a class="title" href="/2021/03/10/JSON%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8C%96/" title="JSON对象转化">JSON对象转化</a><time datetime="2021-03-10T14:10:23.000Z" title="Created 2021-03-10 22:10:23">2021-03-10</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>